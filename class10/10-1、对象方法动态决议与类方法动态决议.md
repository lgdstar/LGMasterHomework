# 对象方法动态决议与类方法动态决议

### 引言

在 《9-3》慢速查找流程中，查看了未查找到的方法的流程，最终输出 `unrecognized selector sent to instance` 相关日志

那么在最终抛出错误日志之前，还有一小段流程，考虑到程序的健壮性，在这段流程中是否存在一些容错处理？ 这次就稍微探究下

### 代码

在源码工程中添加类，以及在 `main` 函数中进行调用

```objc
//声明类 .h 文件中添加方法，在 .m 中不进行实现
- (void)say666;

//使用对象调用该方法
[p say666];
```

此方法由于未实现， 最终崩溃输出日志

```shell
*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[LGTeacher say666]: unrecognized selector sent to instance 0x1012700a0'
```

添加断点，进行中间流程分析

断点位置

- `[p say666];`

-  `lookUpImpOrForward` 函数中 `for` 循环流程结束后的 `if` 判断位置

  ```C++
      for (unsigned attempts = unreasonableClassCount();;) {
        //...省略
      }
  
      // No implementation found. Try method resolver once.
    
      if (slowpath(behavior & LOOKUP_RESOLVER)) {
          behavior ^= LOOKUP_RESOLVER;
          return resolveMethod_locked(inst, sel, cls, behavior);
      }
  ```



## 流程分析

分析慢速查找核心代码 `for` 循环结束后至错误日志输出之间的流程

`for` 循环后的代码

```C++
    // No implementation found. Try method resolver once.
  
    if (slowpath(behavior & LOOKUP_RESOLVER)) {
        behavior ^= LOOKUP_RESOLVER;
        return resolveMethod_locked(inst, sel, cls, behavior);
    }

 done:
    if (fastpath((behavior & LOOKUP_NOCACHE) == 0)) {
#if CONFIG_USE_PREOPT_CACHES
        while (cls->cache.isConstantOptimizedCache(/* strict */true)) {
            cls = cls->cache.preoptFallbackClass();
        }
#endif
        log_and_fill_cache(cls, imp, sel, inst, curClass);
    }
 done_unlock:
    runtimeLock.unlock();
    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {
        return nil;
    }
    return imp;
```

在这些代码中，除了 `done:` 与 `done_unlock:`  对应的代码外，核心的代码就是这个 `if` 语句了

```C++
    // No implementation found. Try method resolver once.
  
    if (slowpath(behavior & LOOKUP_RESOLVER)) {
        behavior ^= LOOKUP_RESOLVER;
        return resolveMethod_locked(inst, sel, cls, behavior);
    }
```

### if (slowpath(behavior & LOOKUP_RESOLVER))

`LOOKUP_RESOLVER` 的值为2

```C++
/* method lookup */
enum {
    LOOKUP_INITIALIZE = 1,
    LOOKUP_RESOLVER = 2,
    LOOKUP_NIL = 4,
    LOOKUP_NOCACHE = 8,
};
```

#### behavior

`behavior` 是 `lookUpImpOrForward` 的入参 `IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)`

搜索 `lookUpImpOrForward` 的传参位置

在 `objc-msg-arm64.s` 中

```assembly
.macro MethodTableLookup
	
	SAVE_REGS MSGSEND

	// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)
	// receiver and selector already in x0 and x1
	mov	x2, x16
	mov	x3, #3
	bl	_lookUpImpOrForward

	// IMP in x0
	mov	x17, x0

	RESTORE_REGS MSGSEND

.endmacro
```

- 根据汇编代码 `mov x3, #3` ，第4个参数传入数据为 3

- 根据注释 `LOOKUP_INITIALIZE | LOOKUP_RESOLVER` 值为 

  ```C++
  1 | 2 = 0001 | 0010 = 0011 = 3
  ```

当前代码环境是在 `Mac` 上运行代码，那么再看下  `objc-msg-x86_64.s`

```assembly
.macro MethodTableLookup

	SAVE_REGS MSGSEND

	// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)
.if $0 == NORMAL
	// receiver already in a1
	// selector already in a2
.else
	movq	%a2, %a1
	movq	%a3, %a2
.endif
	movq	%r10, %a3
	movl	$$3, %a4d
	call	_lookUpImpOrForward

	// IMP is now in %rax
	movq	%rax, %r11

	RESTORE_REGS MSGSEND

.if $0 == NORMAL
	test	%r11, %r11		// set ne for nonstret forwarding
.else
	cmp	%r11, %r11		// set eq for stret forwarding
.endif

.endmacro
```

根据注释的 `LOOKUP_INITIALIZE | LOOKUP_RESOLVER`  此时传入的 `behavior` 参数值也是 3

再使用断点获取数据

```shell
(lldb) po cls
objc[48414]: mutex incorrectly locked
objc[48414]: mutex incorrectly locked
LGTeacher

(lldb) po behavior
3
```

#### behavior & LOOKUP_RESOLVER

根据上面两个值，此时结果为真，进入判断语句

```C++
behavior & LOOKUP_RESOLVER = 3 & 2 = 0011 & 0010 = 0010 
```

#### behavior ^= LOOKUP_RESOLVER

后续执行代码 `behavior ^= LOOKUP_RESOLVER;`

```C++
behavior ^= LOOKUP_RESOLVER;
// behavior = behavior ^ LOOKUP_RESOLVER = 0010 ^ 0010 = 0000
```

#### 延伸

##### 延伸1 单例算法逻辑

上述语句和判断结合，形成了类似单例的算法逻辑

```C++
    if (slowpath(behavior & LOOKUP_RESOLVER)) {
        behavior ^= LOOKUP_RESOLVER;
        //...
    }
```

在执行完成 `^=` 语句后，`behavior` 当前值为 0，此时再执行当前 `if` 语句时必定值为 0，不进入方法内，形成了该代码只执行一次的单例效果

###### 此处单例有什么意义？

此处是顺序执行代码，单例又有什么意义呢？

> 解答：此处代码逻辑中虽然没有循环或多次执行此段代码逻辑，但是在方法查找的整体流程中 lookUpImpOrForward 方法存在多次调用，此时 `behavior` 作为入参进行整体循环传递就体现了单例的效果

##### 延伸2 参数动态变更

使用 `behavior` 这种参数传递方法，可在参数传递中进行动态赋值，作为一个标志更换标志意义，例如后续流程中的

```C++
static NEVER_INLINE IMP
resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) {
  //...省略
          resolveClassMethod(inst, sel, cls);
        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {
            resolveInstanceMethod(inst, sel, cls);
        }
  //...省略
}
```

```C++
IMP lookUpImpOrNilTryCache(id inst, SEL sel, Class cls, int behavior)
{
    return _lookUpImpTryCache(inst, sel, cls, behavior | LOOKUP_NIL);
}

static IMP _lookUpImpTryCache(id inst, SEL sel, Class cls, int behavior)
```

此处进行 `behavior | LOOKUP_NIL` 或操作，就变更了后续作为入参的 `behavior` 

同时此时若再传入 `lookUpImpOrForward` 方法，则`延伸1`中单例又可进入

### resolveMethod_locked

后续执行 `resolveMethod_locked` 函数，其方法实现为

```C++
/***********************************************************************
* resolveMethod_locked
* Call +resolveClassMethod or +resolveInstanceMethod.
*
* Called with the runtimeLock held to avoid pressure in the caller
* Tail calls into lookUpImpOrForward, also to avoid pressure in the callerb
**********************************************************************/
static NEVER_INLINE IMP
resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)
{
    runtimeLock.assertLocked();
    ASSERT(cls->isRealized());

    runtimeLock.unlock();
    if (! cls->isMetaClass()) {
        // try [cls resolveInstanceMethod:sel]
        resolveInstanceMethod(inst, sel, cls);
    } 
    else {
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        resolveClassMethod(inst, sel, cls);
        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {
            resolveInstanceMethod(inst, sel, cls);
        }
    }
    
    // chances are that calling the resolver have populated the cache
    // so attempt using it
    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);
}
```

#### 意义

当前方法的意义：

- 根据当前方法的调用条件，此时对方法的快速查找和慢速查找都进行完成，依然未查询到此方法，说明此 `imp` 未实现为 `nil` 
- 如果此时直接崩溃，也是可以，不过就显得当前系统不友善
- 为了避免崩溃的产生，同时为了加强当前代码和系统的健壮性，使得代码更为友善，此时就添加容错处理，再提供一次解决的机会
- 此时提供了一次动态变换处理，返回一个 `imp` ，这些相关处理就在 `return` 之前进行
- 之后再重新进行查找 `lookUpImpOrForwardTryCache` 

#### return 后续查找流程

##### 源码

```C++
IMP lookUpImpOrForwardTryCache(id inst, SEL sel, Class cls, int behavior)
{
    return _lookUpImpTryCache(inst, sel, cls, behavior);
}

/***********************************************************************
* lookUpImpOrForward / lookUpImpOrForwardTryCache / lookUpImpOrNilTryCache
* The standard IMP lookup.
*
* The TryCache variant attempts a fast-path lookup in the IMP Cache.
* Most callers should use lookUpImpOrForwardTryCache with LOOKUP_INITIALIZE
*
* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)
* With    LOOKUP_NIL: returns nil on negative cache hits
*
* inst is an instance of cls or a subclass thereof, or nil if none is known.
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
* May return _objc_msgForward_impcache. IMPs destined for external use 
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
*   If you don't want forwarding at all, use LOOKUP_NIL.
**********************************************************************/
ALWAYS_INLINE
static IMP _lookUpImpTryCache(id inst, SEL sel, Class cls, int behavior)
{
    runtimeLock.assertUnlocked();

    if (slowpath(!cls->isInitialized())) {
        // see comment in lookUpImpOrForward
        return lookUpImpOrForward(inst, sel, cls, behavior);
    }

    IMP imp = cache_getImp(cls, sel);
    if (imp != NULL) goto done;
#if CONFIG_USE_PREOPT_CACHES
    if (fastpath(cls->cache.isConstantOptimizedCache(/* strict */true))) {
        imp = cache_getImp(cls->cache.preoptFallbackClass(), sel);
    }
#endif
    if (slowpath(imp == NULL)) {
        return lookUpImpOrForward(inst, sel, cls, behavior);
    }

done:
    if ((behavior & LOOKUP_NIL) && imp == (IMP)_objc_msgForward_impcache) {
        return nil;
    }
    return imp;
}
```

根据注释 `The standard IMP lookup.` 可知，此处也是进行了标准的 IMP 查找

##### _lookUpImpTryCache

对 `_lookUpImpTryCache` 的 `IMP lookup` 进行梳理

###### !cls->isInitialized()

```C++
    if (slowpath(!cls->isInitialized())) {
        // see comment in lookUpImpOrForward
        return lookUpImpOrForward(inst, sel, cls, behavior);
    }
```

未初始化，则跳转 `lookUpImpOrForward` ，执行其相关类初始化流程(参考 《9-3、慢速查找流程》)

###### cache_getImp

此方法执行单独缓存查找流程(不执行慢速查找流程)，详细分析参考 《9-3》中 `cache_getImp` 小节

###### CONFIG_USE_PREOPT_CACHES

还进行了共享缓存的查找

###### imp == NULL

```C++
    if (slowpath(imp == NULL)) {
        return lookUpImpOrForward(inst, sel, cls, behavior);
    }
```

方法依然为空时，则继续跳转 `lookUpImpOrForward` ，此时 `behavior` 值为 0，传入最终执行 `return imp` ，`imp` 初始化为 `nil`，最终返回 `nil` 

###### done:

```C++
    if ((behavior & LOOKUP_NIL) && imp == (IMP)_objc_msgForward_impcache) {
        return nil;
    }
```

此处的判断应对的是 `lookUpImpOrNilTryCache` 方法

```C++
IMP lookUpImpOrNilTryCache(id inst, SEL sel, Class cls, int behavior)
{
    return _lookUpImpTryCache(inst, sel, cls, behavior | LOOKUP_NIL);
}
```

其变更入参 `behavior` 的值为 `behavior | LOOKUP_NIL` 了

此处也对应其注释 ` With    LOOKUP_NIL: returns nil on negative cache hits`，在 `imp == (IMP)_objc_msgForward_impcache` 时为 `negative cache` 因此返回 `nil`

#### 中间处理流程

此处再次进行了方法查找，是因为在之前又提供了一次动态变换处理，如果在这次处理中进行了相关操作，就再次执行一次 `The standard IMP lookup` 来查找，因此此处不是冗余的重复行为

那么此时就对中间的处理流程进行分析

##### 源码

```C++
    if (! cls->isMetaClass()) {
        // try [cls resolveInstanceMethod:sel]
        resolveInstanceMethod(inst, sel, cls);
    } 
    else {
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        resolveClassMethod(inst, sel, cls);
        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {
            resolveInstanceMethod(inst, sel, cls);
        }
    }
```

##### ! cls->isMetaClass()

根据 `if` 判断条件，非元类执行 `resolveInstanceMethod(inst, sel, cls);`

###### resolveInstanceMethod

```C++
/***********************************************************************
* resolveInstanceMethod
* Call +resolveInstanceMethod, looking for a method to be added to class cls.
* cls may be a metaclass or a non-meta class.
* Does not check if the method already exists.
**********************************************************************/
static void resolveInstanceMethod(id inst, SEL sel, Class cls)
{
    runtimeLock.assertUnlocked();
    ASSERT(cls->isRealized());
    SEL resolve_sel = @selector(resolveInstanceMethod:);

    if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls->ISA(/*authenticated*/true))) {
        // Resolver not implemented.
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(cls, resolve_sel, sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);

    if (resolved  &&  PrintResolving) {
        if (imp) {
            _objc_inform("RESOLVE: method %c[%s %s] "
                         "dynamically resolved to %p", 
                         cls->isMetaClass() ? '+' : '-', 
                         cls->nameForLogging(), sel_getName(sel), imp);
        }
        else {
            // Method resolver didn't add anything?
            _objc_inform("RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"
                         ", but no new implementation of %c[%s %s] was found",
                         cls->nameForLogging(), sel_getName(sel), 
                         cls->isMetaClass() ? '+' : '-', 
                         cls->nameForLogging(), sel_getName(sel));
        }
    }
}
```

###### -- 流程分析

浏览代码，此方法核心流程是系统发送消息 `resolve_sel`

- `SEL resolve_sel = @selector(resolveInstanceMethod:);`

  首先声明方法 `resolveInstanceMethod:`

- `!lookUpImpOrNilTryCache(cls, resolve_sel, cls->ISA(/*authenticated*/true))` 

  之后使用方法查找进行判断，如果声明的方法未实现 `resolveInstanceMethod:` 即 `Resolver not implemented` 则直接 `return`

  > 注意：此处不会执行 return，因为在 `NSObject.mm` 中存在系统的默认实现方法
  >
  > 即使自己不进行实现，也会有系统的方法来兜底，增加系统的稳定性
  >
  > ```objc
  > + (BOOL)resolveInstanceMethod:(SEL)sel {
  >     return NO;
  > }
  > ```

- 之后进行 `objc_msgSend` 消息发送

  ```C++
  BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
  bool resolved = msg(cls, resolve_sel, sel);
  ```

  使用 `cls` 作为入参 `Class` ，那么当前方法应该是 `+resolveInstanceMethod` 类方法实现，与注释中 `+` 对应

  - 解析：

    根据《7-3》中探索可知，`objc_msgSend` 是对传入的对象的 `isa` 对应的类(或元类等) 的缓存列表或方法列表中的方法数据进行查找

    此时传入的类 `cls` ，实际上查找的是元类的方法列表中的数据，根据 《4-2》中探索可知，类方法存储在元类的方法列表中，因此当前 `resolveInstanceMethod` 方法是以类方法的形式实现的

  - 根据上述解析，如果此时使用 `id inst` 作为入参 `Class` ，那么当前方法应该是 `-` 对象方法

    此处也再次验证了底层不存在 `+` 和 `-` 方法的区分，只是用这两个符号区分类方法和对象方法

- lookUpImpOrNilTryCache

  ```C++
      // Cache the result (good or bad) so the resolver doesn't fire next time.
      // +resolveInstanceMethod adds to self a.k.a. cls
      IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);
  ```

  之后又进行了 `lookUpImpOrNilTryCache` ，在此处进行方法查找

###### -- 存在疑问

此时就存在疑问了，此处为何又进行了 `lookUpImpOrNilTryCache` ，只是单纯的进行后续的日志输出么？

此处的方法查找与 `resolveMethod_locked` 最后的 `return` 语句中的 `lookUpImpOrForwardTryCache` 是否重复了？

###### -- 实操验证

###### ---- 验证准备

- 之前通过断点日志输出可知当前 `cls = LGTeacher`

  ```shell
  (lldb) po cls
  objc[48414]: mutex incorrectly locked
  objc[48414]: mutex incorrectly locked
  LGTeacher
  ```

  那么当前验证时 `resolveInstanceMethod` 方法应该添加到 `LGTeacher` 类中

- 发送消息时

  ```C++
  BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
  bool resolved = msg(cls, resolve_sel, sel);
  ```

  由于是向 `cls` 发送，因此 `resolveInstanceMethod` 应当时类方法，因此代码实现时，在 `LGTeacher.m`  文件中，以类方法 `+ resolveInstanceMethod` 方式实现

###### ---- 验证执行流程

```objc
//LGTeacher.m 中

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSLog(@"%s-%@-%@", __func__, self, NSStringFromSelector(sel));
    return [super resolveInstanceMethod:sel];
}

```

添加此代码后运行源码工程，工程崩溃

```shell
 +[LGTeacher resolveInstanceMethod:]-LGTeacher-say666
 +[LGTeacher resolveInstanceMethod:]-LGTeacher-say666
 -[LGTeacher say666]: unrecognized selector sent to instance 0x10140d160
```

- 当前方法未处理，崩溃是正确的
- 在 `unrecognized selector` 之前，得到日志 `+[LGTeacher resolveInstanceMethod:]-LGTeacher-say666` 输出，证明当前添加的代码已经执行过了
- 为什么输出两次呢？这就是之前的 **存在疑问** 小节中调用了两次查找造成的
- 既然在方法最终崩溃前执行到此方法中，那么在此方法中进行对查找 `sel` 的处理，此时找不到 `sel` 对应的 `imp` ，那么在此处实现该 `imp` 或者动态添加一个 `imp` ，就达到了避免崩溃，解决查找不到当前 `sel` 的问题

###### ---- 验证解决代码

```objc
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSLog(@"%s-%@-%@", __func__, self, NSStringFromSelector(sel));
    
    if (sel == @selector(say666)) {
        IMP sayNBImp = class_getMethodImplementation(self, @selector(sayNB));
        Method method = class_getInstanceMethod(self, @selector(sayNB));
        const char *type = method_getTypeEncoding(method);
        return class_addMethod(self, sel, sayNBImp, type);
    }
    
    return [super resolveInstanceMethod:sel];
}
```

> 注：使用运行时相关方法，需导入头文件 `\#import <objc/message.h>`

 使用 `class_addMethod` 来给当前未实现的 `sel` 添加 `imp` 方法实现，其函数声明如下：

```C++
class_addMethod(<#Class _Nullable cls#>, <#SEL _Nonnull name#>, <#IMP _Nonnull imp#>, <#const char * _Nullable types#>)
```

- 使用 `LGTeacher` 中已实现的对象方法  `sayNB` 方法来替换当前未实现的 `say666` 方法

  ```objc
  @implementation LGTeacher
  
  - (void)sayNB{
      NSLog(@"%@ - %s",self , __func__);
  }
  
  @end
  ```

- `<#Class _Nullable cls#>`  首个参数

  - `class_addMethod` 的具体实现 (参考 3) 是给 `cls` 添加 `method_list_t` 方法列表

  - 当前使用对象方法 `sayNB` ，由于对象方法存储在类的方法列表中，因此当前应当对 `LGTeacher` 类添加方法，因此此处应传递 `LGTeacher` 类对象

  - 由于当前是在类方法中，根据之前的输出 `self` 的输出对应 `LGTeacher`，因此此参数传当前对象 `self` 即可

- `<#SEL _Nonnull name#>` 第二个参数，给当前的 `sel` 添加 `imp` ，传入当前的入参 `sel` 即可

- `<#IMP _Nonnull imp#>` 第三个参数，使用的是 `sayNB` 的 `IMP` ， 使用运行时方法获取 `IMP` 即可  `IMP sayNBImp = class_getMethodImplementation(self, @selector(sayNB));`

- `<#const char * _Nullable types#>` 最后一个参数，编码类型

  按其类型声明参数 `const char *type1 = method_getTypeEncoding(<#Method _Nonnull m#>)` 需要 `Method` 参数

  此时再声明 `Method method = class_getInstanceMethod(self, @selector(sayNB));`

此时运行源码工程，运行正常未崩溃，得到日志

```shell
 +[LGTeacher resolveInstanceMethod:]-LGTeacher-say666
 +[LGTeacher resolveInstanceMethod:]-LGTeacher-encodeWithOSLogCoder:options:maxLength:
 <LGTeacher: 0x101083310> - -[LGTeacher sayNB]
```

此时得到 `sayNB` 方法实现中的打印日志 ` <LGTeacher: 0x101083310> - -[LGTeacher sayNB]` ，证明该方法被调用

###### 总结

当前 `say666` 方法未实现，此次动态地把其 `IMP` 转向了 `sayNB` 的 `IMP` ，同时也避免了程序崩溃的产生

到此处当前对象方法的动态处理就实现了

##### cls->isMetaClass()  -- 类方法动态决议

在判断条件的 `else` 分支，此时 `cls->isMetaClass()` 是分支条件，即当前类是元类，其执行代码为

```C++
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        resolveClassMethod(inst, sel, cls);
        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {
            resolveInstanceMethod(inst, sel, cls);
        }
```

###### resolveClassMethod

首先执行 `resolveClassMethod()` 函数

```C++
/***********************************************************************
* resolveClassMethod
* Call +resolveClassMethod, looking for a method to be added to class cls.
* cls should be a metaclass.
* Does not check if the method already exists.
**********************************************************************/
static void resolveClassMethod(id inst, SEL sel, Class cls)
{
    runtimeLock.assertUnlocked();
    ASSERT(cls->isRealized());
    ASSERT(cls->isMetaClass());

    if (!lookUpImpOrNilTryCache(inst, @selector(resolveClassMethod:), cls)) {
        // Resolver not implemented.
        return;
    }

    Class nonmeta;
    {
        mutex_locker_t lock(runtimeLock);
        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);
        // +initialize path should have realized nonmeta already
        if (!nonmeta->isRealized()) {
            _objc_fatal("nonmeta class %s (%p) unexpectedly not realized",
                        nonmeta->nameForLogging(), nonmeta);
        }
    }
    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveClassMethod adds to self->ISA() a.k.a. cls
    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);

    if (resolved  &&  PrintResolving) {
        if (imp) {
            _objc_inform("RESOLVE: method %c[%s %s] "
                         "dynamically resolved to %p", 
                         cls->isMetaClass() ? '+' : '-', 
                         cls->nameForLogging(), sel_getName(sel), imp);
        }
        else {
            // Method resolver didn't add anything?
            _objc_inform("RESOLVE: +[%s resolveClassMethod:%s] returned YES"
                         ", but no new implementation of %c[%s %s] was found",
                         cls->nameForLogging(), sel_getName(sel), 
                         cls->isMetaClass() ? '+' : '-', 
                         cls->nameForLogging(), sel_getName(sel));
        }
    }
}
```

###### -- 流程分析

当前流程与之前的 `resolveInstanceMethod` 类似，相同逻辑代码就不再分析，只分析部分不同的代码

- `Class nonmeta`  根据直译应为 **非元类** ，再粗略查看其赋值方法 `getMaybeUnrealizedNonMetaClass`  [参考2]，可知其方法就是获取非元类的类或者根据当前元类得到对应的类

- 那么之后的 `objc_msgSend` 本质上与 `resolveInstanceMethod` 中的逻辑相同，都是对 `cls` 类进行消息发送，则可知 `resolveClassMethod` 方法同样应以类方法方式实现

  ```C++
   bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);
  ```

###### -- 实操验证

###### ---- 验证准备

当前分支判断条件为 `cls` 为元类

根据之前探索可知，类的 `isa` 指向元类，那么当调用类方法时，在执行的动态决议流程时，会执行到此分支下 

> 类方法发送时，传递参数验证详见 `拓展1`

此时添加类方法声明和调用代码

```objc
+ (void)sayHappy;

// main函数中
[LGTeacher sayHappy];  //此行添加断点
```

断点捕捉后输出

```shell
(lldb) p/x LGTeacher.class
(Class) $0 = 0x0000000100008398 LGTeacher
(lldb) x/4gx 0x0000000100008398 
0x100008398: 0x0000000100008370 0x00000001000083e8
0x1000083a8: 0x00000001003359c0 0x0000802000000000
```

在 `LookUpImpOrForward` 中 `resolveMethod_locked` 代码行添加断点，输出 `cls`

```shell
(lldb) po cls
objc[34789]: mutex incorrectly locked
objc[34789]: mutex incorrectly locked
0x0000000100008370

(lldb) po sel
"sayHappy"
```

证实当前 `cls` 传递数据为 `LGTeacher` 类的元类地址

###### ---- 验证执行流程

```objc
//LGTeacher.m 中新增
+ (BOOL)resolveClassMethod:(SEL)sel
{
    NSLog(@"%s-%@-%@", __func__, self, NSStringFromSelector(sel));
    return [super resolveClassMethod:sel];
}
```

运行源码工程，输出日志

```shell
 +[LGTeacher resolveClassMethod:]-LGTeacher-sayHappy
 +[LGTeacher resolveClassMethod:]-LGTeacher-sayHappy
 +[LGTeacher sayHappy]: unrecognized selector sent to class 0x100008398
```

证明当前方法在流程中进行了执行

###### ---- 验证解决代码

```objc
//LGTeacher.m
+ (BOOL)resolveClassMethod:(SEL)sel
{
    NSLog(@"%s-%@-%@", __func__, self, NSStringFromSelector(sel));
    
    if (sel == @selector(sayHappy)) {
        IMP sayImp = class_getMethodImplementation(objc_getMetaClass("LGTeacher"), @selector(sayKC));
        Method method = class_getInstanceMethod(objc_getMetaClass("LGTeacher"), @selector(sayKC));
        const char *type = method_getTypeEncoding(method);
        return class_addMethod(objc_getMetaClass("LGTeacher"), sel, sayImp, type);
    }
    
    return [super resolveClassMethod:sel];
}
```

当前解决方式与对象方法决议的代码类似，相同部分就不再解析了，对不同部分进行分析下

- 使用 `LGTeacher` 中已实现的类方法  `sayKC` 方法来替换当前未实现的 `sayHappy` 方法

  ```objc
  @implementation LGTeacher
  
  + (void)sayKC{
      NSLog(@"%@ - %s",self , __func__);
  }
  
  @end
  ```

-  `class_getMethodImplementation` 、`class_getInstanceMethod` 与 `class_addMethod`  函数的首个参数 `Class cls` 传递值更换为 `objc_getMetaClass("LGTeacher")` 

  -  `class_addMethod` 的具体实现 (参考 3) 是给 `cls` 添加 `method_list_t` 方法列表

  - 当前是替换类方法，类方法存储在元类的方法列表中，因此 `cls` 参数需传入元类

    ```C++
    /***********************************************************************
    * class_getClassMethod.  Return the class method for the specified
    * class and selector.
    **********************************************************************/
    Method class_getClassMethod(Class cls, SEL sel)
    {
        if (!cls  ||  !sel) return nil;
    
        return class_getInstanceMethod(cls->getMeta(), sel);
    }
    ```

    根据类方法获取方法的实现也可证实，获取类方法即是获取元类的对象方法

  - 使用 `objc_getMetaClass("LGTeacher")` 获取元类对象

此时运行源码工程，运行正常未崩溃，得到日志

```shell
+[LGTeacher resolveClassMethod:]-LGTeacher-sayHappy
LGTeacher - +[LGTeacher sayKC]
```

此时得到类方法 `sayKC` 方法实现中的打印日志 `LGTeacher - +[LGTeacher sayKC]` ，证明该方法被调用

###### ---- 验证结果

当前 `sayHappy` 类方法未实现，此次动态地把其 `IMP` 转向了 `sayKC` 的 `IMP` ，同时也避免了程序崩溃的产生

到此处当前类方法的动态处理就实现了

###### resolveInstanceMethod

当前流程中，在 `resolveClassMethod` 方法执行后，其后面再次进行了  `resolveInstanceMethod` ，这是为什么呢

###### -- 解析

类方法等同于元类的对象方法，当前的判断分支条件即是 `cls` 是元类

因此当前的解决流程可以执行两条线路

- 从类方法上使用 `resolveClassMethod` 来解决
- 从元类的对象方法上，使用 `resolveInstanceMethod` 来解决

##### 提出问题

之前对类方法的解决方式已经验证，那么对元类的对象方法应该怎样实现？

- 元类并不是程序员添加的实际类
- `resolveInstanceMethod` 方式的解决方式，需要在当前传入的元类对象中添加类方法，那么这个类方法应该写在哪呢？

###### 解析

查看元类的继承链(参考 《4-1》中 isa走位图)可知，元类可追溯至根元类，根元类的父类是根类(`NSObject`)，那么 `NSObject` 就是可以添加 `resolveInstanceMethod` 类方法的元类了

于此同时 `NSObject` 是 `类`的继承链上的根类，那么无论是  `resolveInstanceMethod` 解决对象方法动态决议，还是`resolveClassMethod` 类方法的动态决议，都可以添加到 `NSObject` 的实现当中

综合上述两点，无论是对象方法决议还是类方法决议，都可以在 `NSObject ` 中进行实现，来解决方法未实现的问题，那么来验证下

###### 验证

`NSObject` 是系统类，我们无法也不应该去直接更改，那么分类/类目 就是一种比较好的方式了

在类目中，只要实现 `resolveInstanceMethod` 类方法，在此方法中可同时对对象方法和类方法做动态处理，因为他们最终都会执行到此处

###### 代码

创建 `NSObject+LGD` 类目，在 `.m` 文件中实现对对象方法和类方法的动态决议处理方法

```objc
#import <objc/message.h>  //引入头文件

@implementation NSObject (LGD)

- (void)sayNB{
    NSLog(@"%@ - %s",self , __func__);
}

+ (void)sayKC{
    NSLog(@"%@ - %s",self , __func__);
}

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSLog(@"%s-%@-%@", __func__, self, NSStringFromSelector(sel));
    
    if (sel == @selector(say666)) {
        IMP sayNBImp = class_getMethodImplementation(self, @selector(sayNB));
        Method method = class_getInstanceMethod(self, @selector(sayNB));
        const char *type = method_getTypeEncoding(method);
        return class_addMethod(self, sel, sayNBImp, type);
    } else if (sel == @selector(sayHappy)) {
        IMP sayImp = class_getMethodImplementation(objc_getMetaClass("LGTeacher"), @selector(sayKC));
        Method method = class_getInstanceMethod(objc_getMetaClass("LGTeacher"), @selector(sayKC));
        const char *type = method_getTypeEncoding(method);
        return class_addMethod(objc_getMetaClass("LGTeacher"), sel, sayImp, type);
    }
    
    return NO;
}
```

- 存在变动是 `return NO;` 由于 `NSObject` 的父类是 `nil` 了，因此此处直接和 `NSObject` 的系统实现中一致直接返回 `NO`  

###### 运行

运行源码工程，`main` 函数同时调用未实现的对象方法和类方法

```C++
int main(int argc, const char * argv[]) {
    @autoreleasepool {
      
        LGTeacher *p = [LGTeacher alloc];
        [LGTeacher sayHappy];
        [p say666];

        NSLog(@"Hello, World!");
    }
    return 0;
}
```

查看运行日志

```shell

 +[NSObject(LG) resolveInstanceMethod:]-LGTeacher-sayHappy
 LGTeacher - +[LGTeacher sayKC]

 +[NSObject(LG) resolveInstanceMethod:]-LGTeacher-say666
 <LGTeacher: 0x1007c8730> - -[LGTeacher sayNB]

 Hello, World!
Program ended with exit code: 0
```

根据输出日志可验证，类方法和对象方法的动态解决均被 `NSObject+LGD` 类目中的 `resolveInstanceMethod` 方法捕获并转发

###### 总结

写在 `NSObject` 的类目中这种方式的优点

- 使用 `resolveInstanceMethod` 可同时处理对象方法和类方法的动态决议
- 可以在 `NSObject` 处理所有类的方法，无需在单独的类中单独实现 `resolveInstanceMethod` 和 `resolveClassMethod` 方法

## 总结

研究了这些动态决议方法，这些方法有什么意义呢？

当前执行到此的流程是由于指定的 `SEL` 找不到对应的 `IMP`

- 苹果官方系统给了一次机会来解决 `IMP` 未实现的问题，如果造成最终的App崩溃那必然是对用户不友善的
- 此处在 `NSObject` 类目中的 `resolveInstanceMethod`  方式必然能监听到全局的所有的找不到 `IMP` 的方法
-  应用示例
  - 使用 `工程名_模块名_事务` 命名规则来声明方法
  - 只监控当前规则命名的相关方法(系统方法无需hook，只需 hook 开发的方法)，在指定模块方法调用出错时，可直接跳转回指定模块，同时在后台进行错误上报，提交开发人员修改 bug
  - 利用 `runtime` 的一些动态派发 `@selector()` 等方式实现方法调用时，会出现相关的问题
  - 这种方式的思维、侵入的修改方式，归属于 `AOP(Aspect Oriented Programming)` 面向切面编程，在之后稍微拓展下此方面内容



## 参考

### 参考1 lookUpImpOrForward

```C++
IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)
{
    const IMP forward_imp = (IMP)_objc_msgForward_impcache;
    IMP imp = nil;
    Class curClass;

    runtimeLock.assertUnlocked();

    if (slowpath(!cls->isInitialized())) {
        // The first message sent to a class is often +new or +alloc, or +self
        // which goes through objc_opt_* or various optimized entry points.
        //
        // However, the class isn't realized/initialized yet at this point,
        // and the optimized entry points fall down through objc_msgSend,
        // which ends up here.
        //
        // We really want to avoid caching these, as it can cause IMP caches
        // to be made with a single entry forever.
        //
        // Note that this check is racy as several threads might try to
        // message a given class for the first time at the same time,
        // in which case we might cache anyway.
        behavior |= LOOKUP_NOCACHE;
    }

    // runtimeLock is held during isRealized and isInitialized checking
    // to prevent races against concurrent realization.

    // runtimeLock is held during method search to make
    // method-lookup + cache-fill atomic with respect to method addition.
    // Otherwise, a category could be added but ignored indefinitely because
    // the cache was re-filled with the old value after the cache flush on
    // behalf of the category.

    runtimeLock.lock();

    // We don't want people to be able to craft a binary blob that looks like
    // a class but really isn't one and do a CFI attack.
    //
    // To make these harder we want to make sure this is a class that was
    // either built into the binary or legitimately registered through
    // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.
    checkIsKnownClass(cls);

    cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior & LOOKUP_INITIALIZE);
    // runtimeLock may have been dropped but is now locked again
    runtimeLock.assertLocked();
    curClass = cls;

    // The code used to lookup the class's cache again right after
    // we take the lock but for the vast majority of the cases
    // evidence shows this is a miss most of the time, hence a time loss.
    //
    // The only codepath calling into this without having performed some
    // kind of cache lookup is class_getInstanceMethod().

    for (unsigned attempts = unreasonableClassCount();;) {
        if (curClass->cache.isConstantOptimizedCache(/* strict */true)) {
#if CONFIG_USE_PREOPT_CACHES
            imp = cache_getImp(curClass, sel);
            if (imp) goto done_unlock;
            curClass = curClass->cache.preoptFallbackClass();
#endif
        } else {
            // curClass method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                imp = meth->imp(false);
                goto done;
            }

            if (slowpath((curClass = curClass->getSuperclass()) == nil)) {
                // No implementation found, and method resolver didn't help.
                // Use forwarding.
                imp = forward_imp;
                break;
            }
        }

        // Halt if there is a cycle in the superclass chain.
        if (slowpath(--attempts == 0)) {
            _objc_fatal("Memory corruption in class list.");
        }

        // Superclass cache.
        imp = cache_getImp(curClass, sel);
        if (slowpath(imp == forward_imp)) {
            // Found a forward:: entry in a superclass.
            // Stop searching, but don't cache yet; call method
            // resolver for this class first.
            break;
        }
        if (fastpath(imp)) {
            // Found the method in a superclass. Cache it in this class.
            goto done;
        }
    }

    // No implementation found. Try method resolver once.
  
    if (slowpath(behavior & LOOKUP_RESOLVER)) {
        behavior ^= LOOKUP_RESOLVER;
        return resolveMethod_locked(inst, sel, cls, behavior);
    }

 done:
    if (fastpath((behavior & LOOKUP_NOCACHE) == 0)) {
#if CONFIG_USE_PREOPT_CACHES
        while (cls->cache.isConstantOptimizedCache(/* strict */true)) {
            cls = cls->cache.preoptFallbackClass();
        }
#endif
        log_and_fill_cache(cls, imp, sel, inst, curClass);
    }
 done_unlock:
    runtimeLock.unlock();
    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {
        return nil;
    }
    return imp;
}
```

### 参考2 getMaybeUnrealizedNonMetaClass

```C++
/***********************************************************************
* getMaybeUnrealizedNonMetaClass
* Return the ordinary class for this class or metaclass. 
* `inst` is an instance of `cls` or a subclass thereof, or nil. 
* Non-nil inst is faster.
* The result may be unrealized.
* Used by +initialize. 
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static Class getMaybeUnrealizedNonMetaClass(Class metacls, id inst)
{
    static int total, named, secondary, sharedcache, dyld3;
    runtimeLock.assertLocked();
    ASSERT(metacls->isRealized());

    total++;

    // return cls itself if it's already a non-meta class
    if (!metacls->isMetaClass()) return metacls;

    // metacls really is a metaclass
    // which means inst (if any) is a class

    // special case for root metaclass
    // where inst == inst->ISA() == metacls is possible
    if (metacls->ISA() == metacls) {
        Class cls = metacls->getSuperclass();
        ASSERT(cls->isRealized());
        ASSERT(!cls->isMetaClass());
        ASSERT(cls->ISA() == metacls);
        if (cls->ISA() == metacls) return cls;
    }

    // use inst if available
    if (inst) {
        Class cls = remapClass((Class)inst);
        // cls may be a subclass - find the real class for metacls
        // fixme this probably stops working once Swift starts
        // reallocating classes if cls is unrealized.
        while (cls) {
            if (cls->ISA() == metacls) {
                ASSERT(!cls->isMetaClassMaybeUnrealized());
                return cls;
            }
            cls = cls->getSuperclass();
        }
#if DEBUG
        _objc_fatal("cls is not an instance of metacls");
#else
        // release build: be forgiving and fall through to slow lookups
#endif
    }

    // See if the metaclass has a pointer to its nonmetaclass.
    if (Class cls = metacls->bits.safe_ro()->getNonMetaclass())
        return cls;

    // try name lookup
    {
        Class cls = getClassExceptSomeSwift(metacls->mangledName());
        if (cls && cls->ISA() == metacls) {
            named++;
            if (PrintInitializing) {
                _objc_inform("INITIALIZE: %d/%d (%g%%) "
                             "successful by-name metaclass lookups",
                             named, total, named*100.0/total);
            }
            return cls;
        }
    }

    // try secondary table
    {
        Class cls = (Class)NXMapGet(nonMetaClasses(), metacls);
        if (cls) {
            secondary++;
            if (PrintInitializing) {
                _objc_inform("INITIALIZE: %d/%d (%g%%) "
                             "successful secondary metaclass lookups",
                             secondary, total, secondary*100.0/total);
            }

            ASSERT(cls->ISA() == metacls);            
            return cls;
        }
    }

    // try the dyld closure table
    if (isPreoptimized())
    {
        // Try table from dyld closure first.  It was built to ignore the dupes it
        // knows will come from the cache, so anything left in here was there when
        // we launched
        Class cls = nil;
        // Note, we have to pass the lambda directly here as otherwise we would try
        // message copy and autorelease.
        _dyld_for_each_objc_class(metacls->mangledName(),
                                  [&cls, metacls](void* classPtr, bool isLoaded, bool* stop) {
          // Skip images which aren't loaded.  This supports the case where dyld
          // might soft link an image from the main binary so its possibly not
          // loaded yet.
          if (!isLoaded)
            return;

          // Found a loaded image with this class name, so check if its the right one
          Class result = (Class)classPtr;
          if (result->ISA() == metacls) {
              cls = result;
              *stop = true;
          }
        });

        if (cls) {
            dyld3++;
            if (PrintInitializing) {
                _objc_inform("INITIALIZE: %d/%d (%g%%) "
                             "successful dyld closure metaclass lookups",
                             dyld3, total, dyld3*100.0/total);
            }

            return cls;
        }
    }

    // try any duplicates in the dyld shared cache
    {
        Class cls = nil;

        int count;
        Class *classes = copyPreoptimizedClasses(metacls->mangledName(),&count);
        if (classes) {
            for (int i = 0; i < count; i++) {
                if (classes[i]->ISA() == metacls) {
                    cls = classes[i];
                    break;
                }
            }
            free(classes);
        }

        if (cls) {
            sharedcache++;
            if (PrintInitializing) {
                _objc_inform("INITIALIZE: %d/%d (%g%%) "
                             "successful shared cache metaclass lookups",
                             sharedcache, total, sharedcache*100.0/total);
            }

            return cls;
        }
    }

    _objc_fatal("no class for metaclass %p", (void*)metacls);
}
```

### 参考3  class_addMethod

```C++
BOOL 
class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return NO;

    mutex_locker_t lock(runtimeLock);
    return ! addMethod(cls, name, imp, types ?: "", NO);
}

/**********************************************************************
* addMethod
* fixme
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static IMP 
addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)
{
    IMP result = nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);
    
    ASSERT(types);
    ASSERT(cls->isRealized());

    method_t *m;
    if ((m = getMethodNoSuper_nolock(cls, name))) {
        // already exists
        if (!replace) {
            result = m->imp(false);
        } else {
            result = _method_setImplementation(cls, m, imp);
        }
    } else {
        // fixme optimize
        method_list_t *newlist;
        newlist = (method_list_t *)calloc(method_list_t::byteSize(method_t::bigSize, 1), 1);
        newlist->entsizeAndFlags = 
            (uint32_t)sizeof(struct method_t::big) | fixed_up_method_list;
        newlist->count = 1;
        auto &first = newlist->begin()->big();
        first.name = name;
        first.types = strdupIfMutable(types);
        first.imp = imp;

        addMethods_finish(cls, newlist);
        result = nil;
    }

    return result;
}

static void
addMethods_finish(Class cls, method_list_t *newlist)
{
    auto rwe = cls->data()->extAllocIfNeeded();

    if (newlist->count > 1) {
        method_t::SortBySELAddress sorter;
        std::stable_sort(&newlist->begin()->big(), &newlist->end()->big(), sorter);
    }

    prepareMethodLists(cls, &newlist, 1, NO, NO, __func__);
    rwe->methods.attachLists(&newlist, 1);

    // If the class being modified has a constant cache,
    // then all children classes are flattened constant caches
    // and need to be flushed as well.
    flushCaches(cls, __func__, [](Class c){
        // constant caches have been dealt with in prepareMethodLists
        // if the class still is constant here, it's fine to keep
        return !c->cache.isConstantOptimizedCache();
    });
}
```





## 拓展

### 拓展1 类方法调用时消息发送流程参数验证

#### 代码

```objc
@interface Person : NSObject

+ (void)sayMaster;

@end
  
//---- main 函数
  int main(int argc, char * argv[]) {
    @autoreleasepool {
        Person *person = [[Person alloc] init]; //用于避免进入首次初始化流程
        [Person sayMaster];

        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```

在 `[Person sayMaster];` 行添加断点，进行 `Always Show Disassembly`  汇编代码显示设置

#### 验证

在断点捕捉到显示对应汇编代码后，按照流程跳转到 `objc_msgSend`

```assembly
libobjc.A.dylib`objc_msgSend:
    0x1af112a60 <+0>:   cmp    x0, #0x0                  ; =0x0 
    0x1af112a64 <+4>:   b.le   0x1af112ae0               ; <+128>
    0x1af112a68 <+8>:   ldr    x13, [x0]
    0x1af112a6c <+12>:  and    x16, x13, #0xffffffff8
->  0x1af112a70 <+16>:  ldr    x11, [x16, #0x10]
```

此时进行寄存器输出

```shell
(lldb) register read x0
      x0 = 0x00000001020f8548  (void *)0x00000001020f8520: Person
(lldb) register read x13
     x13 = 0x00000001020f8520  (void *)0x00000001fd9204b0: NSObject
(lldb) register read x16
     x16 = 0x00000001020f8520  (void *)0x00000001fd9204b0: NSObject
(lldb) register read x1
      x1 = 0x00000001020cd52f  "sayMaster"
```

此时对应进入 `CacheLookup` 函数使用的相关寄存器参数

```C++
	//   - x0 contains the receiver
	//   - x1 contains the selector
	//   - x16 contains the isa
```

此时可验证 `x0` 传入的是 类对象 `Person` 

```shell
(lldb) p/x Person.class
(Class) $0 = 0x00000001020f8548 Person # 等于 x0
```

查看其内存地址后，可验证当前 `x16` 存储的是类的 `isa` 指向的元类

```shell
(lldb) x/4gx 0x00000001020f8548
0x1020f8548: 0x00000001020f8520 0x00000001fd9204d8
0x1020f8558: 0x00030002831d0b80 0x0001801000000000

# 0x00000001020f8520 = x16
```

##### lookUpImpOrForward 验证

在 `_objc_msgSend_uncached` 跳转 `lookUpImpOrForward` 慢速查找流程前再次验证参数

```assembly
libobjc.A.dylib`_objc_msgSend_uncached:
    0x1af112de0 <+0>:   pacibsp 
    0x1af112de4 <+4>:   stp    x29, x30, [sp, #-0x10]!
    0x1af112de8 <+8>:   mov    x29, sp
    0x1af112dec <+12>:  sub    sp, sp, #0xd0             ; =0xd0 
    0x1af112df0 <+16>:  stp    q0, q1, [sp]
    0x1af112df4 <+20>:  stp    q2, q3, [sp, #0x20]
    0x1af112df8 <+24>:  stp    q4, q5, [sp, #0x40]
    0x1af112dfc <+28>:  stp    q6, q7, [sp, #0x60]
    0x1af112e00 <+32>:  stp    x0, x1, [sp, #0x80]
    0x1af112e04 <+36>:  stp    x2, x3, [sp, #0x90]
    0x1af112e08 <+40>:  stp    x4, x5, [sp, #0xa0]
    0x1af112e0c <+44>:  stp    x6, x7, [sp, #0xb0]
    0x1af112e10 <+48>:  str    x8, [sp, #0xc0]
    0x1af112e14 <+52>:  mov    x2, x16
    0x1af112e18 <+56>:  mov    x3, #0x3
->  0x1af112e1c <+60>:  bl     0x1af1263dc               ; lookUpImpOrForward
```

输出寄存器存值

```shell
(lldb) register read x0
      x0 = 0x00000001020f8548  (void *)0x00000001020f8520: Person
(lldb) register read x1
      x1 = 0x00000001020cd52f  "sayMaster"
(lldb) register read x2
      x2 = 0x00000001020f8520  (void *)0x00000001fd9204b0: NSObject
```

##### resolveMethod_locked 验证

```assembly
libobjc.A.dylib`resolveMethod_locked:
```

在进入此汇编代码时，输出寄存器值验证参数

```shell
(lldb) register read x0
      x0 = 0x00000001020f8548  (void *)0x00000001020f8520: Person
(lldb) register read x1
      x1 = 0x00000001020cd52f  "sayMaster"
(lldb) register read x2
      x2 = 0x00000001020f8520  (void *)0x00000001fd9204b0: NSObject
```

#### 结论

验证结果证实类方法进入消息发送流程后，`cls` 参数值为其 `isa` 指向的元类

