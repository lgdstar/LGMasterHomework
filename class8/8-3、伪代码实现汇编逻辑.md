## æ±‡ç¼–é€»è¾‘ä¼ªä»£ç å®ç°

### å¼•æ–‡

åœ¨å‰ä¸€ç¯‡ `8-2` ä¸­å¯¹ `objc_msgSend` åŸç†çš„ `CacheLookup` çš„ç›¸å…³æ±‡ç¼–æºç è¿›è¡Œäº†åˆ†æï¼Œæœ¬æ–‡ä¸­å¯¹å…¶ä¸­çš„é‡è¦æ–¹æ³•è¿›è¡Œä¼ªä»£ç å®ç°ï¼Œä»¥ä¾¿æ¢³ç†æ€è·¯åŠ æ·±ç†è§£

### CacheLookup

å¯¹ `CacheLookup` çš„æ•´ä½“æµç¨‹è¿›è¡Œä¼ªä»£ç å®ç°

```swift
	// calls imp or objc_msgSend_uncached
CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached

// x1 = selector,  x16 = class to be searched

LLookupStart

if arm64_64 && (osx || SIMULATOR) {
  
  cache_t = isa + 0x10  //cache_t åœ°å€ç”± isaåœ°å€è¿›è¡Œ 0x10 çš„åœ°å€åç§»
  cache_mask = cache_t >> maskShift  // maskShift = 48
  //  bucketsMask = (1 << maskShift) - 1 = 0xffffffffffff
  buckets = cache_t & bucketsMask  // ä½¿ç”¨æ©ç è·å–ä½48ä½çš„ buckets
  index = cache_hash() = sel & cache_mask  // ä½¿ç”¨ hash æ–¹æ³•è·å–ç´¢å¼•å€¼

} else if arm64_64 { //çœŸæœº
  
  cache_t = isa + #CACHE  //cache_t åœ°å€ç”± isaåœ°å€è¿›è¡Œ 0x10 çš„åœ°å€åç§»
  
  if arm64 && OS_IOS && !OS_SIMULATOR && !OS_MAC_CATALYST { //CONFIG_USE_PREOPT_CACHES
    maskShift = 48
    
    if Clang ç¼–è¯‘å™¨å’Œå½“å‰è¯­è¨€æ ‡å‡†çš„è§„æ ¼æ”¯æŒ æŒ‡é’ˆéªŒè¯ { 
      //arm64e 
      //A12 å¤„ç†å™¨ä»¥ä¸Š / iPhone XS ç³»åˆ—ä¹‹å
      
      if cache_t<0> != 0 { //cache_tç¬¬0ä½æ˜¯å¦ä¸º0
        
        return LLookupPreopt\Function
      } else {
        // é preoptCache å½¢å¼çš„æ™®é€šæ ·å¼ cache_t
        // _bucketsAndMaybeMask is a buckets_t pointer in the low 48 bits
        
        // 1 << 48 - 1 =  0x0000ffffffffffff
        buchets = cache_t & 0x0000ffffffffffff // ä½¿ç”¨æ©ç è·å– _bucketsAndMaybeMask
      }
      
    } else {
      preoptBucketsMask = 0x0000fffffffffffe
      preoptBuckets = cache_t & preoptBucketsMask
      if cache_t<0> != 0 {  //cache_tç¬¬0ä½æ˜¯å¦ä¸º0
        
        return LLookupPreopt\Function
      }
    }
    
    // _maybeMask is unused, the mask is stored in the top 16 bits.
    mask = cache_t >> maskShift  // >> 48
    index = (_cmd ^ (_cmd >> 7)) & mask // ä½¿ç”¨å½“å‰ç®—æ³•æ–¹æ³•è·å–ç´¢å¼•å€¼
    
  } else {
    
    cache_t = isa + #CACHE  //cache_t åœ°å€ç”± isaåœ°å€è¿›è¡Œ 0x10 çš„åœ°å€åç§»
    
    // _bucketsAndMaybeMask is a buckets_t pointer in the low 48 bits
    // 1 << 48 - 1 =  0x0000ffffffffffff
    buchets = cache_t & 0x0000ffffffffffff // ä½¿ç”¨æ©ç è·å– _bucketsAndMaybeMask
    
    // _maybeMask is unused, the mask is stored in the top 16 bits.
    maskShift = 48
    mask = cache_t >> maskShift  // >> 48
    index = cache_hash() = sel & mask  // ä½¿ç”¨ hash æ–¹æ³•è·å–ç´¢å¼•å€¼
  }

} else if arm64_32 {
      // _bucketsAndMaybeMask is a buckets_t pointer in the top 28 bits
    // _maybeMask is unused, the mask length is stored in the low 4 bits
  
  // maskBits = 4
  cache_t = isa + 0x10  //cache_t åœ°å€ç”± isaåœ°å€è¿›è¡Œ 0x10 çš„åœ°å€åç§»
  maskMask = (1 << maskBits) - 1 = 0xf
  bucketsMask = ~maskMask = ~0xf
    
  buckets = cache_t & bucketsMask  // ä½¿ç”¨æ©ç è·å–é«˜28ä½çš„ buckets  
  maskShift = cache_t & maskMask  // ä½¿ç”¨æ©ç è·å–ä½4ä½çš„ maybeMask çš„é•¿åº¦
  cache_mask = 0xffff >> maskShift // mask()å‡½æ•°å®ç° [å‚è€ƒ1]

  index = cache_hash() = sel & cache_mask  // ä½¿ç”¨ hash æ–¹æ³•è·å–ç´¢å¼•å€¼
} else {
  #error Unsupported cache mask storage for ARM64.
}

// index << (1 + 3) == index * 16  16ä¸º bucket_t å•ä½é•¿åº¦
curBucket_t = buckets + index * 0x10  //åç§»é•¿åº¦è·å–ç´¢å¼•å€¼å¯¹åº” bucket_t

repeat {

  // bucket_t = {imp, sel}  arm64ä¸‹ impåœ¨å‰selåœ¨å
  curIMP = curBucket_t 
  curSEL = curBucket_t + 0x08
  curBucket_t -= Bucket_Size // Bucket_Size = 2 * 8 è‡ªå‡åç§»å‰ä¸€ä¸ª

  if curSEL == x1 {
    return CacheHit Normal //ç¼“å­˜å‘½ä¸­
  } else if curSEL == 0 {
    return __objc_msgSend_uncached //æ–¹æ³•æœªç¼“å­˜
  }
} while curBucket_t >= buckets //ä¸å°äºé¦–åœ°å€æ—¶

// curBucket_t < bucketsé¦–åœ°å€
if arm64_64 && (osx || SIMULATOR) {
  //æ¥ä¸Šä¸€ä¸ªåŒç±»å‹åˆ¤æ–­
  //cache_mask = cache_t >> maskShift  // maskShift = 48
  
  lastIndex  = mask() = cache_mask = capacity - 1 // mask() å‡½æ•°å®ç° [å‚è€ƒ1]
  lastBucket_t = buchets + lastIndex * 0x10
  
} else if arm64_64 { //çœŸæœº
  // _maybeMask is unused, the mask is stored in the top 16 bits.
  maskShift = 48
  mask = cache_t >> maskShift  // >> 48
  
  lastIndex = mask // mask ä¸­å­˜å‚¨ buckets.count - 1
  lastBucket_t = buchets + lastIndex * 0x10

} else if arm64_32 {
  //æ¥ä¸Šä¸€ä¸ª arm64_32 åˆ¤æ–­
  //cache_mask = 0xffff >> maskShift
  
  lastIndex  = mask() = cache_mask = capacity - 1 // mask() å‡½æ•°å®ç° [å‚è€ƒ1]
  lastBucket_t = buchets + lastIndex * 0x10
} else {
  
  #error Unsupported cache mask storage for ARM64.
}

curBucket_t = buckets + index * 0x10 //è®°å½•ä¸Šæ¬¡å¾ªç¯æŸ¥æ‰¾çš„é¦–ä¸ªbucket_tï¼Œæ¥è®¾å®šæ­¤æ¬¡æŸ¥æ‰¾è¾¹ç•Œï¼Œå†æ¬¡æŸ¥åˆ°å°±è¯´æ˜å®¹å™¨ä¸­ bucket_t å·²å…¨éƒ¨æŸ¥è¿‡ä¸€é

repeat {
  
  // bucket_t = {imp, sel}  arm64ä¸‹ impåœ¨å‰selåœ¨å
  curIMP = lastBucket_t 
  curSEL = lastBucket_t + 0x08
  lastBucket_t -= Bucket_Size // Bucket_Size = 2 * 8 è‡ªå‡åç§»å‰ä¸€ä¸ª
  
  if curSEL == x1 {
    return CacheHit Normal //ç¼“å­˜å‘½ä¸­
  }
  
} while curSEL ï¼= 0 && lastBucket_t > curBucket_t

// curSEL == 0 || lastBucket_t == curBucket_t 
// æ–¹æ³•æœªç¼“å­˜ æˆ– ç¼“å­˜æŸ¥æ‰¾ä¸€éæœªæ‰¾åˆ°
LLookupEnd:
LLookupRecover:
	return __objc_msgSend_uncached

```

### LLookupPreopt

#### å‰ç½®æ¡ä»¶

```swift
if arm64 && OS_IOS && !OS_SIMULATOR && !OS_MAC_CATALYST { //CONFIG_USE_PREOPT_CACHES
  
  if !arm64_64 {
    #error config unsupported
    return
  }
  
  //arm64_64 çœŸæœº
  LLookupPreopt\Function:
}
```

#### å®ç°

```swift
if Clang ç¼–è¯‘å™¨å’Œå½“å‰è¯­è¨€æ ‡å‡†çš„è§„æ ¼æ”¯æŒ æŒ‡é’ˆéªŒè¯ { 
  //arm64e 
  //A12 å¤„ç†å™¨ä»¥ä¸Š / iPhone XS ç³»åˆ—ä¹‹å
  preoptBucketsMask = 0x007ffffffffffffe
  preoptBuckets = cache_t & preoptBucketsMask
  // autdb preoptBuckets cls()
  ptrauth_auth_data(preoptBuckets, ptrauth_key_process_dependent_data, cls())
}

//è·å–ğŸ¤¯çš„åˆ†é¡µåŸºåœ°å€
first_shared_cache_sel_page_addr = _MagicSelRef@PAGE //ğŸ¤¯@PAGE
//åœ¨åˆ†é¡µå†…è¿›è¡Œåç§»
first_shared_cache_sel = first_shared_cache_sel_page_addr + _MagicSelRef@PAGEOFF
//è·å–åœ°å€åç§»é‡
offs = _cmd - first_shared_cache_sel 

if Clang ç¼–è¯‘å™¨å’Œå½“å‰è¯­è¨€æ ‡å‡†çš„è§„æ ¼æ”¯æŒ æŒ‡é’ˆéªŒè¯ { 
  
  params = preoptBuckets >> 55
  
  // è‡ªå®šä¹‰æ­¤ç®—æ³•ï¼Œä½¿ç”¨æ©ç  0x0f è·å–ä½4ä½æ•°æ®
  // ç­‰åŒäºé€»è¾‘ lsr	w9, w12, w17 32ä½å¯„å­˜å™¨å–å€¼ä¸è¶…è¿‡32ï¼Œå³å–ä½4ä½æ•°æ®
  hash_shift  = params & 0x0f  
  
  mask_bits = preoptBuckets >> 60
  hash_mask = 0x7fff >> mask_bits //åº”å¯¹ hash_mask å¯ä¸º0çš„æƒ…å†µï¼Œä½¿ç”¨ 0x7fff
  
  slot = offs >> hash_shift & hash_mask
} else {
  
  hash_params = preoptBuckets >> 48
  hash_mask   = preoptBuckets >> 53
  
  // è‡ªå®šä¹‰æ­¤ç®—æ³•ï¼Œä½¿ç”¨æ©ç  0x0f è·å–ä½4ä½æ•°æ®
  // ç­‰åŒäºé€»è¾‘ lsr	w9, w12, w17 32ä½å¯„å­˜å™¨å–å€¼ä¸è¶…è¿‡32ï¼Œå³å–ä½4ä½æ•°æ®
  hash_shift  = hash_params & 0x0f  
  
  slot = offs >> hash_shift & hash_mask
}

curr_preopt_cache_entry_t = entries[slot]  // entries + slot * sizeof(preopt_cache_entry_t)

// è‡ªå®šä¹‰ç®—æ³•ï¼Œä½¿ç”¨æ©ç  0xffffffff  è·å–ä½32ä½çš„ imp_offs
curr_preopt_cache_entry_t.sel_offs =  curr_preopt_cache_entry_t  & 0xffffffff 
if curr_preopt_cache_entry_t.sel_offs == offs {
  
  if \Mode == GETIMP {
    //è·å–é«˜32ä½çš„ imp_offs
    curr_preopt_cache_entry_t.imp_offs =  curr_preopt_cache_entry_t >> 32
    
    imp = isa - curr_preopt_cache_entry_t.imp_offs
    
    if JOP { //ptrauth_calls
      PAC(imp)  //è®¡ç®—å’Œæ’å…¥ Pointer Authentication Code
    } 
    return  // imp æ”¾åœ¨x0å¯„å­˜å™¨ï¼Œå¯ä½œä¸ºç»“æœè·å–
    
  } else if \Mode == NORMAL {
    
    curr_preopt_cache_entry_t.imp_offs =  curr_preopt_cache_entry_t >> 32
    
    imp = isa - curr_preopt_cache_entry_t.imp_offs
    imp() // br imp è·³è½¬ imp åœ°å€
    
  } else if \Mode == LOOUP {
    
    curr_preopt_cache_entry_t.imp_offs =  curr_preopt_cache_entry_t >> 32
    
    imp = isa - curr_preopt_cache_entry_t.imp_offs
    isa = isa | 0x11 //for instrumentation, note that we hit a constant cache
    
    if JOP { //ptrauth_calls
      PAC(imp)  //è®¡ç®—å’Œæ’å…¥ Pointer Authentication Code
    } 
    return // imp æ”¾åœ¨x17å¯„å­˜å™¨
    
  } else {
    
    // unhandled mode \Mode 
    return 
  }
  
} else {
  //cache miss
  if \Mode == GETIMP {
    
    return \MissLabelConstat
  } else {
    
    fallback_class_offset = entries - sizeof(hash_params) - sizeof(fallback_class_offset) //4 + 4 å‘ä¸Šåç§»8
    
    newIsa = cls() + fallback_class_offset
    return LLookupStart   //å›åˆ° CacheLookup é‡æ–°æŸ¥æ‰¾æ–°çš„ isa
  }
  
}

```

### CacheHit

```swift
CacheHit \Mode

if Mode == NORMAL {
  if JOP {
    
    pointAuth_modifier = bucket ^ SEL ^ isa
    authIMP = pointAuth(imp, pointAuth_modifier)
    br authIMP  //è·³è½¬
  } else {
    
    originalImp = imp ^ isa  //è§£ç 
    br originalImp
  }
} else if Mode == GETIMP {
  
  if imp == nil {
    return imp
  }
  
  if JOP {
    pointAuth_modifier = bucket ^ SEL ^ isa
    authIMP = authInstrucionAdd(imp, KeyB, pointAuth_modifier) //éªŒè¯æ—§æ–¹æ¡ˆå¹¶é‡ç­¾
    
    if loadAddress(xzr,authIMP) == crash {
      //authentication fails
      return crash
    }
    
    //authentication passes
    return PAC(authIMP)
  } else {
    
    return imp ^ isa
  }
} else if Mode == LOOKUP {
  
  if JOP {
    pointAuth_modifier = bucket ^ SEL ^ isa
    authIMP = authInstrucionAdd(imp, KeyB, pointAuth_modifier) //éªŒè¯æ—§æ–¹æ¡ˆå¹¶é‡ç­¾
    
    if loadAddress(xzr,authIMP) == crash {
      //authentication fails
      return crash
    }
    
    //authentication passes
    ResignIMP = PAC(authIMP)
  } else {
    
    ResignIMP = imp ^ isa
  }
  
  while isa != originalIsa {
    isa += 1
  }
  
  return ResignIMP
  
}
```





## å‚è€ƒ

### å‚è€ƒ1  arm64ä¸‹çš„ cache_t::mask() 

æ ¹æ®  `capacity()` å‡½æ•°å®ç°é€»è¾‘å¯è¯å® `mask = bukect_t å®¹å™¨çš„å®¹é‡ - 1`

```C++
unsigned cache_t::capacity() const
{
    return mask() ? mask()+1 : 0; 
}
```

åœ¨ `arm64` ä¸‹çš„ `mask()`ç›¸å…³å®ç°æ–¹æ³•

```c++
#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED
//çœç•¥ éarm64 åœ¨ã€Š6-3ã€cache_tæºç åˆ†æã€‹ reallocate() å°èŠ‚ä¸­è¿›è¡Œäº†æ­¤æšä¸¾ä¸‹çš„ setBucketsAndMask å‡½æ•°åˆ†æ

#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 || CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16_BIG_ADDRS

void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask)
{
    uintptr_t buckets = (uintptr_t)newBuckets;
    uintptr_t mask = (uintptr_t)newMask;

    ASSERT(buckets <= bucketsMask);
    ASSERT(mask <= maxMask);

    _bucketsAndMaybeMask.store(((uintptr_t)newMask << maskShift) | (uintptr_t)newBuckets, memory_order_relaxed);
    _occupied = 0;
}

mask_t cache_t::mask() const
{
    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);
    return maskAndBuckets >> maskShift;
}

#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4

void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask)
{
    uintptr_t buckets = (uintptr_t)newBuckets;
    unsigned mask = (unsigned)newMask;

    ASSERT(buckets == (buckets & bucketsMask));
    ASSERT(mask <= 0xffff);

    _bucketsAndMaybeMask.store(buckets | objc::mask16ShiftBits(mask), memory_order_relaxed);
    _occupied = 0;

    ASSERT(this->buckets() == newBuckets);
    ASSERT(this->mask() == newMask);
}

mask_t cache_t::mask() const
{
    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);
    uintptr_t maskShift = (maskAndBuckets & maskMask);
    return 0xffff >> maskShift;
}

#else
#error Unknown cache mask storage type.
#endif
```

